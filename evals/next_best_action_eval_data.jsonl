{"query": "Analyze customer churn data and create a predictive model to identify at-risk customers", "response": "Intent: customer_churn_analysis\n\nAction Plan (5 steps):\n  Step 1: Data Collection - Gather customer transaction history, engagement metrics, and support tickets\n  Step 2: Feature Engineering - Create churn indicators such as declining usage, payment delays, and sentiment scores\n  Step 3: Model Training - Train a gradient boosting classifier on historical churn data\n  Step 4: Validation - Evaluate model performance using precision, recall, and AUC-ROC\n  Step 5: Deployment - Deploy model as an API endpoint for real-time scoring", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_churn_001", "name": "next_best_action", "arguments": {"task": "Analyze customer churn data and create a predictive model"}}], "ground_truth_intent": "customer_churn_analysis", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Set up a CI/CD pipeline for deploying microservices to Kubernetes", "response": "Intent: cicd_pipeline_setup\n\nAction Plan (6 steps):\n  Step 1: Repository Setup - Configure Git repository with branch protection and code review requirements\n  Step 2: Build Configuration - Create Dockerfiles for each microservice with multi-stage builds\n  Step 3: CI Pipeline - Set up GitHub Actions or Azure DevOps pipeline for automated builds and tests\n  Step 4: Container Registry - Push built images to Azure Container Registry with proper tagging\n  Step 5: Kubernetes Manifests - Create deployment, service, and ingress YAML files\n  Step 6: CD Pipeline - Configure ArgoCD or Flux for GitOps-based continuous deployment", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_cicd_001", "name": "next_best_action", "arguments": {"task": "Set up CI/CD pipeline for Kubernetes microservices"}}], "ground_truth_intent": "cicd_pipeline_setup", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Design a REST API for a user management system with authentication", "response": "Intent: api_design_user_management\n\nAction Plan (5 steps):\n  Step 1: API Specification - Define OpenAPI/Swagger specification with endpoints for users, roles, and permissions\n  Step 2: Authentication Design - Implement OAuth 2.0 / JWT-based authentication with refresh tokens\n  Step 3: Data Model - Design user, role, and permission database schema with proper relationships\n  Step 4: Endpoint Implementation - Create CRUD endpoints with input validation and error handling\n  Step 5: Security Hardening - Add rate limiting, input sanitization, and audit logging", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_api_001", "name": "next_best_action", "arguments": {"task": "Design REST API for user management"}}], "ground_truth_intent": "api_design", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "What's the next best action for improving customer retention for account #12345?", "response": "Intent: customer_retention_action\n\nAction Plan (4 steps):\n  Step 1: Account Analysis - Review account #12345 usage patterns, support history, and payment status\n  Step 2: Risk Assessment - Calculate churn probability score based on recent activity decline\n  Step 3: Personalized Outreach - Schedule proactive call with account manager to address concerns\n  Step 4: Value Demonstration - Prepare ROI report and product roadmap presentation for stakeholder meeting", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_retention_001", "name": "get_account_profile", "arguments": {"account_id": "12345"}}, {"type": "tool_call", "tool_call_id": "call_retention_002", "name": "recommend_next_actions", "arguments": {"account_context": {"id": "12345", "status": "at_risk"}}}], "tool_outputs": [{"tool_call_id": "call_retention_001", "output": {"name": "Acme Corp", "status": "at_risk", "last_activity": "2025-01-15"}}, {"tool_call_id": "call_retention_002", "output": {"action": "schedule_call", "priority": "high"}}], "ground_truth_intent": "customer_retention", "system_message": "You are a Next Best Action agent that analyzes accounts and recommends retention actions."}
{"query": "Build a data pipeline to ingest real-time streaming data from IoT sensors", "response": "Intent: data_pipeline_iot\n\nAction Plan (5 steps):\n  Step 1: Ingestion Layer - Set up Azure Event Hubs or Kafka for high-throughput sensor data ingestion\n  Step 2: Stream Processing - Implement Azure Stream Analytics or Spark Streaming for real-time transformations\n  Step 3: Data Storage - Configure time-series database (Azure Data Explorer or InfluxDB) for sensor readings\n  Step 4: Anomaly Detection - Add real-time anomaly detection using streaming ML models\n  Step 5: Monitoring Dashboard - Create Power BI or Grafana dashboards for operational visibility", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_iot_001", "name": "next_best_action", "arguments": {"task": "Build IoT data pipeline"}}], "ground_truth_intent": "data_pipeline_setup", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Implement a recommendation engine for an e-commerce platform", "response": "Intent: recommendation_engine\n\nAction Plan (5 steps):\n  Step 1: Data Collection - Gather user browsing history, purchase data, and product catalog information\n  Step 2: Collaborative Filtering - Implement user-based and item-based collaborative filtering algorithms\n  Step 3: Content-Based Filtering - Add product attribute matching for cold-start recommendations\n  Step 4: Hybrid Model - Combine collaborative and content-based approaches with weighted ensemble\n  Step 5: A/B Testing - Deploy recommendation service with experimentation framework for optimization", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_rec_001", "name": "next_best_action", "arguments": {"task": "Implement e-commerce recommendation engine"}}], "ground_truth_intent": "ml_recommendation_system", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Migrate a monolithic application to microservices architecture", "response": "Intent: application_modernization\n\nAction Plan (6 steps):\n  Step 1: Domain Analysis - Identify bounded contexts and service boundaries using domain-driven design\n  Step 2: Strangler Pattern - Implement facade to gradually redirect traffic to new microservices\n  Step 3: Database Decomposition - Split monolithic database into service-specific data stores\n  Step 4: API Gateway - Set up API gateway for routing, authentication, and rate limiting\n  Step 5: Service Mesh - Implement Istio or Linkerd for service-to-service communication\n  Step 6: Observability - Add distributed tracing, logging, and metrics collection", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_migrate_001", "name": "next_best_action", "arguments": {"task": "Migrate monolith to microservices"}}], "ground_truth_intent": "application_modernization", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Create a disaster recovery plan for cloud infrastructure", "response": "Intent: disaster_recovery_planning\n\nAction Plan (5 steps):\n  Step 1: Risk Assessment - Identify critical systems, RTO/RPO requirements, and failure scenarios\n  Step 2: Backup Strategy - Configure geo-redundant backups with automated testing and validation\n  Step 3: Failover Architecture - Design active-passive or active-active multi-region deployment\n  Step 4: Runbook Creation - Document step-by-step recovery procedures for each failure scenario\n  Step 5: DR Testing - Schedule regular failover drills and update procedures based on lessons learned", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_dr_001", "name": "next_best_action", "arguments": {"task": "Create disaster recovery plan"}}], "ground_truth_intent": "disaster_recovery", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Optimize database performance for a high-traffic web application", "response": "Intent: database_optimization\n\nAction Plan (5 steps):\n  Step 1: Query Analysis - Profile slow queries using explain plans and query execution statistics\n  Step 2: Index Optimization - Create appropriate indexes based on query patterns and remove unused ones\n  Step 3: Connection Pooling - Configure connection pooling to reduce connection overhead\n  Step 4: Read Replicas - Set up read replicas to distribute query load across multiple instances\n  Step 5: Caching Layer - Implement Redis or Memcached for frequently accessed data", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_db_001", "name": "next_best_action", "arguments": {"task": "Optimize database performance"}}], "ground_truth_intent": "database_optimization", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
{"query": "Implement security best practices for a new Azure deployment", "response": "Intent: security_implementation\n\nAction Plan (6 steps):\n  Step 1: Identity Management - Configure Azure AD with MFA, conditional access, and PIM\n  Step 2: Network Security - Implement NSGs, Azure Firewall, and private endpoints\n  Step 3: Data Protection - Enable encryption at rest and in transit with customer-managed keys\n  Step 4: Security Monitoring - Set up Microsoft Defender for Cloud and Azure Sentinel\n  Step 5: Compliance - Configure Azure Policy for regulatory compliance (SOC2, HIPAA, etc.)\n  Step 6: Secret Management - Use Azure Key Vault for centralized secret and certificate management", "tool_calls": [{"type": "tool_call", "tool_call_id": "call_sec_001", "name": "next_best_action", "arguments": {"task": "Implement Azure security best practices"}}], "ground_truth_intent": "security_implementation", "system_message": "You are a Next Best Action agent that analyzes tasks and generates action plans."}
