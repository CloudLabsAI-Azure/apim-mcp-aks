{
  "id": "task-instruction-cicd-kubernetes",
  "title": "CI/CD Pipeline Setup for Microservices on Kubernetes",
  "category": "devops",
  "intent": "infrastructure_automation",
  "keywords": ["CI/CD", "pipeline", "microservices", "Kubernetes", "Docker", "GitHub Actions", "Azure DevOps", "deployment", "containers"],
  "description": "Complete guide for setting up a CI/CD pipeline to deploy microservices to Kubernetes clusters.",
  "content": "# CI/CD Pipeline Setup for Microservices on Kubernetes\n\n## Overview\nThis guide covers setting up a production-grade CI/CD pipeline for deploying microservices to Kubernetes. We'll use GitHub Actions as the primary CI/CD tool with Azure Kubernetes Service (AKS) as the target platform.\n\n## Prerequisites\n- GitHub repository with microservices code\n- Azure subscription with AKS cluster\n- Azure Container Registry (ACR) for Docker images\n- kubectl and Azure CLI installed locally\n\n## Phase 1: Repository Structure\n\n### 1.1 Recommended Project Structure\n```\n├── .github/\n│   └── workflows/\n│       ├── ci.yaml\n│       ├── cd-dev.yaml\n│       └── cd-prod.yaml\n├── services/\n│   ├── api-gateway/\n│   │   ├── src/\n│   │   ├── Dockerfile\n│   │   └── k8s/\n│   ├── user-service/\n│   ├── order-service/\n│   └── notification-service/\n├── k8s/\n│   ├── base/\n│   │   ├── kustomization.yaml\n│   │   └── namespace.yaml\n│   ├── overlays/\n│   │   ├── dev/\n│   │   ├── staging/\n│   │   └── prod/\n├── scripts/\n└── docker-compose.yaml\n```\n\n### 1.2 Dockerfile Best Practices\n```dockerfile\n# Multi-stage build for Node.js microservice\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\n\n# Production stage\nFROM node:20-alpine AS production\nWORKDIR /app\nRUN addgroup -g 1001 -S nodejs && adduser -S nodejs -u 1001\nCOPY --from=builder --chown=nodejs:nodejs /app/dist ./dist\nCOPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules\nUSER nodejs\nEXPOSE 3000\nCMD [\"node\", \"dist/main.js\"]\n```\n\n## Phase 2: Continuous Integration (CI)\n\n### 2.1 CI Workflow Configuration\n```yaml\n# .github/workflows/ci.yaml\nname: CI Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\nenv:\n  REGISTRY: myacr.azurecr.io\n  \njobs:\n  detect-changes:\n    runs-on: ubuntu-latest\n    outputs:\n      services: ${{ steps.filter.outputs.changes }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dorny/paths-filter@v2\n        id: filter\n        with:\n          filters: |\n            api-gateway: 'services/api-gateway/**'\n            user-service: 'services/user-service/**'\n            order-service: 'services/order-service/**'\n\n  build-and-test:\n    needs: detect-changes\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        service: ${{ fromJson(needs.detect-changes.outputs.services) }}\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n          cache-dependency-path: services/${{ matrix.service }}/package-lock.json\n      \n      - name: Install dependencies\n        working-directory: services/${{ matrix.service }}\n        run: npm ci\n      \n      - name: Run linting\n        working-directory: services/${{ matrix.service }}\n        run: npm run lint\n      \n      - name: Run tests\n        working-directory: services/${{ matrix.service }}\n        run: npm test -- --coverage\n      \n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          directory: services/${{ matrix.service }}/coverage\n\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Run Trivy vulnerability scanner\n        uses: aquasecurity/trivy-action@master\n        with:\n          scan-type: 'fs'\n          scan-ref: '.'\n          severity: 'CRITICAL,HIGH'\n\n  build-images:\n    needs: [build-and-test, detect-changes]\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        service: ${{ fromJson(needs.detect-changes.outputs.services) }}\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Log in to Azure Container Registry\n        uses: azure/docker-login@v1\n        with:\n          login-server: ${{ env.REGISTRY }}\n          username: ${{ secrets.ACR_USERNAME }}\n          password: ${{ secrets.ACR_PASSWORD }}\n      \n      - name: Build and push Docker image\n        uses: docker/build-push-action@v5\n        with:\n          context: services/${{ matrix.service }}\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: |\n            ${{ env.REGISTRY }}/${{ matrix.service }}:${{ github.sha }}\n            ${{ env.REGISTRY }}/${{ matrix.service }}:latest\n```\n\n## Phase 3: Continuous Deployment (CD)\n\n### 3.1 Kubernetes Manifests with Kustomize\n```yaml\n# k8s/base/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: SERVICE_NAME\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: SERVICE_NAME\n  template:\n    metadata:\n      labels:\n        app: SERVICE_NAME\n    spec:\n      containers:\n      - name: SERVICE_NAME\n        image: IMAGE_PLACEHOLDER\n        ports:\n        - containerPort: 3000\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: SERVICE_NAME\nspec:\n  selector:\n    app: SERVICE_NAME\n  ports:\n  - port: 80\n    targetPort: 3000\n  type: ClusterIP\n```\n\n### 3.2 CD Workflow\n```yaml\n# .github/workflows/cd-prod.yaml\nname: CD Production\n\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n\nenv:\n  REGISTRY: myacr.azurecr.io\n  CLUSTER_NAME: my-aks-cluster\n  RESOURCE_GROUP: my-rg\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Azure Login\n        uses: azure/login@v1\n        with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n      \n      - name: Get AKS credentials\n        run: |\n          az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.CLUSTER_NAME }}\n      \n      - name: Deploy with Kustomize\n        run: |\n          cd k8s/overlays/prod\n          kustomize edit set image IMAGE_PLACEHOLDER=${{ env.REGISTRY }}/api-gateway:${{ github.sha }}\n          kubectl apply -k .\n      \n      - name: Verify deployment\n        run: |\n          kubectl rollout status deployment/api-gateway -n production --timeout=300s\n      \n      - name: Run smoke tests\n        run: |\n          ./scripts/smoke-test.sh\n```\n\n## Phase 4: Advanced Configurations\n\n### 4.1 GitOps with ArgoCD (Alternative)\n```yaml\n# argocd/application.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: microservices-app\n  namespace: argocd\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/org/repo.git\n    targetRevision: HEAD\n    path: k8s/overlays/prod\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: production\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n```\n\n### 4.2 Helm Charts for Complex Deployments\n```yaml\n# charts/microservice/values.yaml\nreplicaCount: 2\n\nimage:\n  repository: myacr.azurecr.io/service\n  tag: latest\n  pullPolicy: IfNotPresent\n\nservice:\n  type: ClusterIP\n  port: 80\n\ningress:\n  enabled: true\n  className: nginx\n  hosts:\n    - host: api.example.com\n      paths:\n        - path: /\n          pathType: Prefix\n\nautoscaling:\n  enabled: true\n  minReplicas: 2\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 70\n```\n\n## Phase 5: Monitoring and Observability\n\n### 5.1 Prometheus and Grafana Setup\n- Install kube-prometheus-stack via Helm\n- Configure service monitors for each microservice\n- Create custom dashboards for business metrics\n\n### 5.2 Logging with ELK/Loki\n- Deploy Loki stack for log aggregation\n- Configure structured logging in applications\n- Set up alerting rules for error rates\n\n## Best Practices\n\n1. **Image Tagging**: Use Git SHA for production, semantic versioning for releases\n2. **Secrets Management**: Use Azure Key Vault or Sealed Secrets\n3. **Progressive Deployment**: Implement canary or blue-green deployments\n4. **Resource Quotas**: Set appropriate resource requests and limits\n5. **Network Policies**: Implement zero-trust networking between services\n6. **Health Checks**: Configure liveness and readiness probes for all services\n\n## Troubleshooting Common Issues\n\n- **Image Pull Errors**: Verify ACR credentials and image tags\n- **Pod Crashes**: Check logs with `kubectl logs` and events with `kubectl describe`\n- **Resource Issues**: Monitor with `kubectl top pods` and adjust limits\n- **Network Issues**: Verify service discovery and network policies",
  "estimated_effort": "high",
  "steps": [
    {"step": 1, "action": "Repository Setup", "description": "Structure repository with services, k8s manifests, and workflow directories"},
    {"step": 2, "action": "Dockerfile Creation", "description": "Create optimized multi-stage Dockerfiles for each service"},
    {"step": 3, "action": "CI Workflow", "description": "Configure GitHub Actions for testing, linting, and building images"},
    {"step": 4, "action": "Container Registry", "description": "Set up ACR and configure authentication"},
    {"step": 5, "action": "Kubernetes Manifests", "description": "Create deployment, service, and ingress manifests with Kustomize"},
    {"step": 6, "action": "CD Workflow", "description": "Configure automated deployment to AKS cluster"},
    {"step": 7, "action": "Monitoring", "description": "Set up Prometheus, Grafana, and logging stack"}
  ],
  "related_tasks": ["container orchestration", "Docker deployment", "DevOps automation", "infrastructure as code"]
}
