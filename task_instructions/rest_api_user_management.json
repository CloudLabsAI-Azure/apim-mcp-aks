{
  "id": "task-instruction-rest-api-auth",
  "title": "REST API Design for User Management with Authentication",
  "category": "api_development",
  "intent": "system_design",
  "keywords": ["REST API", "user management", "authentication", "authorization", "JWT", "OAuth", "API design", "security", "RBAC"],
  "description": "Complete guide for designing and implementing a secure REST API for user management with modern authentication patterns.",
  "content": "# REST API Design for User Management with Authentication\n\n## Overview\nThis guide covers designing a production-ready REST API for user management with comprehensive authentication and authorization. We'll implement JWT-based authentication with refresh tokens, role-based access control (RBAC), and follow REST best practices.\n\n## Phase 1: API Design Principles\n\n### 1.1 RESTful Resource Modeling\n```\nResources:\n- Users: /api/v1/users\n- Authentication: /api/v1/auth\n- Roles: /api/v1/roles\n- Permissions: /api/v1/permissions\n- Sessions: /api/v1/sessions\n```\n\n### 1.2 API Endpoint Structure\n```\nUser Management:\n  POST   /api/v1/users              - Create new user\n  GET    /api/v1/users              - List users (paginated)\n  GET    /api/v1/users/{id}         - Get user by ID\n  PUT    /api/v1/users/{id}         - Update user\n  PATCH  /api/v1/users/{id}         - Partial update\n  DELETE /api/v1/users/{id}         - Delete user\n  GET    /api/v1/users/me           - Get current user profile\n  PUT    /api/v1/users/me           - Update current user profile\n\nAuthentication:\n  POST   /api/v1/auth/register      - User registration\n  POST   /api/v1/auth/login         - User login\n  POST   /api/v1/auth/logout        - User logout\n  POST   /api/v1/auth/refresh       - Refresh access token\n  POST   /api/v1/auth/forgot-password  - Request password reset\n  POST   /api/v1/auth/reset-password   - Reset password with token\n  POST   /api/v1/auth/verify-email     - Verify email address\n  POST   /api/v1/auth/2fa/enable    - Enable 2FA\n  POST   /api/v1/auth/2fa/verify    - Verify 2FA code\n\nRole Management:\n  GET    /api/v1/roles              - List roles\n  POST   /api/v1/roles              - Create role\n  GET    /api/v1/roles/{id}         - Get role\n  PUT    /api/v1/roles/{id}         - Update role\n  DELETE /api/v1/roles/{id}         - Delete role\n  PUT    /api/v1/users/{id}/roles   - Assign roles to user\n```\n\n## Phase 2: Data Models\n\n### 2.1 User Schema\n```python\nfrom pydantic import BaseModel, EmailStr, Field\nfrom typing import Optional, List\nfrom datetime import datetime\nfrom enum import Enum\n\nclass UserStatus(str, Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n    SUSPENDED = \"suspended\"\n    PENDING_VERIFICATION = \"pending_verification\"\n\nclass UserCreate(BaseModel):\n    email: EmailStr\n    password: str = Field(..., min_length=8, max_length=128)\n    first_name: str = Field(..., min_length=1, max_length=50)\n    last_name: str = Field(..., min_length=1, max_length=50)\n    phone: Optional[str] = None\n\nclass UserResponse(BaseModel):\n    id: str\n    email: EmailStr\n    first_name: str\n    last_name: str\n    phone: Optional[str]\n    status: UserStatus\n    roles: List[str]\n    created_at: datetime\n    updated_at: datetime\n    last_login: Optional[datetime]\n    email_verified: bool\n    two_factor_enabled: bool\n\nclass UserUpdate(BaseModel):\n    first_name: Optional[str] = Field(None, min_length=1, max_length=50)\n    last_name: Optional[str] = Field(None, min_length=1, max_length=50)\n    phone: Optional[str] = None\n```\n\n### 2.2 Authentication Models\n```python\nclass LoginRequest(BaseModel):\n    email: EmailStr\n    password: str\n    remember_me: bool = False\n\nclass TokenResponse(BaseModel):\n    access_token: str\n    refresh_token: str\n    token_type: str = \"bearer\"\n    expires_in: int  # seconds\n\nclass RefreshTokenRequest(BaseModel):\n    refresh_token: str\n```\n\n## Phase 3: Authentication Implementation\n\n### 3.1 JWT Token Service\n```python\nimport jwt\nfrom datetime import datetime, timedelta\nfrom typing import Optional, Dict, Any\nimport secrets\n\nclass JWTService:\n    def __init__(\n        self,\n        secret_key: str,\n        algorithm: str = \"HS256\",\n        access_token_expire_minutes: int = 15,\n        refresh_token_expire_days: int = 7\n    ):\n        self.secret_key = secret_key\n        self.algorithm = algorithm\n        self.access_token_expire = timedelta(minutes=access_token_expire_minutes)\n        self.refresh_token_expire = timedelta(days=refresh_token_expire_days)\n\n    def create_access_token(self, user_id: str, roles: list, additional_claims: Dict = None) -> str:\n        expire = datetime.utcnow() + self.access_token_expire\n        payload = {\n            \"sub\": user_id,\n            \"roles\": roles,\n            \"type\": \"access\",\n            \"exp\": expire,\n            \"iat\": datetime.utcnow(),\n            \"jti\": secrets.token_hex(16)  # Unique token ID for revocation\n        }\n        if additional_claims:\n            payload.update(additional_claims)\n        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n\n    def create_refresh_token(self, user_id: str) -> str:\n        expire = datetime.utcnow() + self.refresh_token_expire\n        payload = {\n            \"sub\": user_id,\n            \"type\": \"refresh\",\n            \"exp\": expire,\n            \"iat\": datetime.utcnow(),\n            \"jti\": secrets.token_hex(16)\n        }\n        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n\n    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])\n            return payload\n        except jwt.ExpiredSignatureError:\n            raise TokenExpiredError(\"Token has expired\")\n        except jwt.InvalidTokenError:\n            raise InvalidTokenError(\"Invalid token\")\n```\n\n### 3.2 Password Hashing\n```python\nfrom passlib.context import CryptContext\nimport secrets\nimport hashlib\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass PasswordService:\n    @staticmethod\n    def hash_password(password: str) -> str:\n        return pwd_context.hash(password)\n    \n    @staticmethod\n    def verify_password(plain_password: str, hashed_password: str) -> bool:\n        return pwd_context.verify(plain_password, hashed_password)\n    \n    @staticmethod\n    def generate_reset_token() -> tuple[str, str]:\n        \"\"\"Generate reset token and its hash for storage\"\"\"\n        token = secrets.token_urlsafe(32)\n        token_hash = hashlib.sha256(token.encode()).hexdigest()\n        return token, token_hash\n```\n\n## Phase 4: API Implementation\n\n### 4.1 FastAPI Authentication Endpoints\n```python\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n\napp = FastAPI(title=\"User Management API\", version=\"1.0.0\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/login\")\n\n@app.post(\"/api/v1/auth/register\", response_model=UserResponse, status_code=201)\nasync def register(\n    user_data: UserCreate,\n    user_service: UserService = Depends(get_user_service)\n):\n    # Check if email already exists\n    existing_user = await user_service.get_by_email(user_data.email)\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail=\"Email already registered\"\n        )\n    \n    # Create user\n    user = await user_service.create(user_data)\n    \n    # Send verification email\n    await send_verification_email(user.email)\n    \n    return user\n\n@app.post(\"/api/v1/auth/login\", response_model=TokenResponse)\nasync def login(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    auth_service: AuthService = Depends(get_auth_service)\n):\n    user = await auth_service.authenticate(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect email or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"}\n        )\n    \n    if user.status == UserStatus.SUSPENDED:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Account suspended\"\n        )\n    \n    # Check 2FA if enabled\n    if user.two_factor_enabled:\n        return {\"requires_2fa\": True, \"temp_token\": create_temp_token(user.id)}\n    \n    tokens = auth_service.create_tokens(user)\n    await auth_service.update_last_login(user.id)\n    \n    return tokens\n```\n\n### 4.2 Authorization Middleware\n```python\nfrom functools import wraps\nfrom typing import List\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme),\n    jwt_service: JWTService = Depends(get_jwt_service),\n    user_service: UserService = Depends(get_user_service)\n) -> UserResponse:\n    payload = jwt_service.verify_token(token)\n    \n    # Check if token is blacklisted (for logout)\n    if await is_token_blacklisted(payload[\"jti\"]):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Token has been revoked\"\n        )\n    \n    user = await user_service.get(payload[\"sub\"])\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"User not found\"\n        )\n    return user\n\ndef require_roles(required_roles: List[str]):\n    \"\"\"Decorator to check user roles\"\"\"\n    async def role_checker(\n        current_user: UserResponse = Depends(get_current_user)\n    ):\n        user_roles = set(current_user.roles)\n        if not user_roles.intersection(set(required_roles)):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Insufficient permissions\"\n            )\n        return current_user\n    return role_checker\n\n# Usage example\n@app.get(\"/api/v1/admin/users\")\nasync def list_all_users(\n    current_user: UserResponse = Depends(require_roles([\"admin\", \"super_admin\"]))\n):\n    return await user_service.list_all()\n```\n\n## Phase 5: Security Best Practices\n\n### 5.1 Rate Limiting\n```python\nfrom slowapi import Limiter, _rate_limit_exceeded_handler\nfrom slowapi.util import get_remote_address\n\nlimiter = Limiter(key_func=get_remote_address)\n\n@app.post(\"/api/v1/auth/login\")\n@limiter.limit(\"5/minute\")  # 5 attempts per minute\nasync def login(request: Request, ...):\n    ...\n```\n\n### 5.2 Security Headers\n```python\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom starlette.middleware.httpsredirect import HTTPSRedirectMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"https://yourdomain.com\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n@app.middleware(\"http\")\nasync def add_security_headers(request, call_next):\n    response = await call_next(request)\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"DENY\"\n    response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n    response.headers[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains\"\n    return response\n```\n\n### 5.3 Input Validation and Sanitization\n- Use Pydantic for automatic validation\n- Implement email verification\n- Enforce password complexity requirements\n- Sanitize user inputs to prevent XSS\n\n## Phase 6: Database Schema\n\n### 6.1 SQL Schema (PostgreSQL)\n```sql\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    first_name VARCHAR(50) NOT NULL,\n    last_name VARCHAR(50) NOT NULL,\n    phone VARCHAR(20),\n    status VARCHAR(20) DEFAULT 'pending_verification',\n    email_verified BOOLEAN DEFAULT FALSE,\n    two_factor_enabled BOOLEAN DEFAULT FALSE,\n    two_factor_secret VARCHAR(255),\n    failed_login_attempts INT DEFAULT 0,\n    lockout_until TIMESTAMP,\n    last_login TIMESTAMP,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE roles (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    name VARCHAR(50) UNIQUE NOT NULL,\n    description TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE user_roles (\n    user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n    role_id UUID REFERENCES roles(id) ON DELETE CASCADE,\n    PRIMARY KEY (user_id, role_id)\n);\n\nCREATE TABLE refresh_tokens (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n    token_hash VARCHAR(255) NOT NULL,\n    expires_at TIMESTAMP NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    revoked BOOLEAN DEFAULT FALSE\n);\n\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_refresh_tokens_user_id ON refresh_tokens(user_id);\n```\n\n## Best Practices Summary\n\n1. **Token Security**: Use short-lived access tokens (15 min) with refresh tokens\n2. **Password Storage**: Always hash with bcrypt, never store plaintext\n3. **Rate Limiting**: Protect authentication endpoints from brute force\n4. **HTTPS Only**: Enforce TLS for all API communications\n5. **Input Validation**: Validate all inputs server-side\n6. **Audit Logging**: Log authentication events for security monitoring\n7. **Account Lockout**: Implement progressive delays after failed attempts\n8. **Secure Headers**: Set appropriate security headers on all responses",
  "estimated_effort": "high",
  "steps": [
    {"step": 1, "action": "API Design", "description": "Define RESTful endpoints and resource models"},
    {"step": 2, "action": "Data Modeling", "description": "Create Pydantic schemas and database models"},
    {"step": 3, "action": "Authentication", "description": "Implement JWT token service with refresh tokens"},
    {"step": 4, "action": "Password Security", "description": "Set up bcrypt hashing and password policies"},
    {"step": 5, "action": "Authorization", "description": "Implement RBAC with role-based middleware"},
    {"step": 6, "action": "Security Hardening", "description": "Add rate limiting, security headers, and input validation"},
    {"step": 7, "action": "Testing", "description": "Write comprehensive API tests and security tests"}
  ],
  "related_tasks": ["API gateway", "OAuth integration", "SSO implementation", "identity management"]
}
